///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

:javadoc-base-url-api: {javadoc-base-url}?io/helidon/grpc/client
:pagename: grpc-server-client-implementation
:description: Helidon gRPC Client Implementation
:keywords: helidon, grpc, java

= Client Implementation

Helidon gRPC client framework allows you to write gRPC clients to access any gRPC
service implementation. The benefits of using Helidon gRPC client framework include:

* It provides a number of helper methods that make client implementation
  significantly simpler.

* It allows you to configure some of the Helidon value-added features, such
  as <<08_security.adoc, security>> and <<07_metrics.adoc, metrics collection and interceptors>>
  down to the method level.

* It allows you to easily specify custom marshaller for requests and
  responses if `protobuf` does not satisfy your needs.

== Client Implementation Basics

* The first step to create a Helidon gRPC client application is to first describe the set of methods in the gRPC service. Helidon
gRPC Client framework (simply called the "Client framework" in the remainder of the document) provides a class called
`ClientServiceDescriptor` to describe the set of methods of a service that the client may invoke.

* The next step is to create a gRPC Channel to use to communicate with the server.

* Finally, you create an instance of `GrpcServiceClient` passing the `ClientMethodDescriptor` and the `Channel` instances.

`ClientServiceDescriptor` can be initialized using `protoc` generated `BindableService` or
from `io.grpc.ServiceDescriptor`. It also provides many methods to programmatically
build the service description. We will see both approaches here.

== Creating gRPC clients from protoc generated artifacts.

The easiest way to create a `ClientServiceDescriptor` is to create it from an `io.grpc.ServiceDescriptor` or
from a `io.grpc.BindableService`. It is fairly trivial to obtain these from a service generated from artifacts generated
from IDL file.

For this we will assume the following proto file:

[source, proto]
----
syntax = "proto3";
option java_package = "io.helidon.grpc.client.test";

service StringService {
  rpc Upper (StringMessage) returns (StringMessage) {}                  // (Unary)
  rpc Lower (StringMessage) returns (StringMessage) {}                  // (Unary)
  rpc Split (StringMessage) returns (stream StringMessage) {}           // (Server streaming)
  rpc Join (stream StringMessage) returns (StringMessage) {}            // (Client Streaming)
  rpc Echo (stream StringMessage) returns (stream StringMessage) {}     // (Bidi streaming)
}

message StringMessage {
  string text = 1;
}
----

If you run it through protoc it will generate a class (among other things) called `StringServiceGrpc`.
Assuming that the StringService is running on port 1408, here is how you can create the Helidon gRPC Client.

[source,java]
----
public class StringServiceClient {

    public static void main(String[] args) {
        ClientServiceDescriptor desc = ClientServiceDescriptor
                .builder(StringService.getServiceDescriptor())                  // (1)
                .build();

        Channel channel = ManagedChannelBuilder.forAddress("localhost", 1408)   // (2)
                .usePlaintext().build();

        GrpcServiceClient client = GrpcServiceClient.create(channel, desc);     // (3)

        CompletableFuture<String> result = client.unary("Lower", "ABC");        // (4)
    }

}
----

1. Initialize the builder by specifying the `StringService`'s proto `ServiceDescriptor`. From
the `ServiceDescriptor` the builder detects the service name, the set of method names, and for
each method its type (like Unary, ServerStreaming etc.), the appropriate Marshallers etc.

2. We create a `Channel` to the service that is running on `localhost:1408`.

3. Finally, we create our `GrpcServiceClient` by using the above mentioned `ClientServiceDescriptor`
and `Channel`.

4. Finally, we invoke the `Lower` method (which returns a CompletableFuture).

== Programmatically creating ClientServiceDescriptor for StringService

Assuming that the service is still running on port 1408, lets see how to create our Client
without using the `StringService` 's proto `ServiceDescriptor`.

Since we are *not* going to use the `StringService` 's proto `ServiceDescriptor`, we need to
describe the methods that the client need to invoke. The Helidon client framework provides a
bunch of APIs to easily describe gRPC methods.

For example, to register a unary method, we need to use the `unary` method and configure it to
specify the request and response types.

Other than describing the methods that our client will invoke, the rest of the following
code should be very similar (or same) as the previous section!!

[source,java]
----
public class StringServiceClient {

    public static void main(String[] args) {
        ClientMethodDescriptor methodDesc = ClientMethodDescriptor
                    .unary("StringService", "Lower")                            // (1)
                    .requestType(StringMessage.class)                           // (2)
                    .responseType(StringMessage.class)                          // (3)
                    .build();                                                   // (4)

        ClientServiceDescriptor desc = ClientServiceDescriptor
                .builder(StringService.class)                                   // (5)
                .unary("Lower", methodDesc)                                     // (6)
                .build();

        Channel channel = ManagedChannelBuilder.forAddress("localhost", 1408)   // (7)
                .usePlaintext().build();

        GrpcServiceClient client = GrpcServiceClient.create(channel, desc);     // (8)

        CompletableFuture<String> result = client.unary("Lower", "ABC");        // (9)
    }

}
----

1. Create a `ClientMethodDescriptor` for the "Unary" type `Lower` method in the `StringService`. named `StringService`.
2. Set the request type of the method to be `StringMessage` (since the `Lower` method takes `StringMessage` as a parameter).
3. Set the response type of the method to be `StringMessage` (since the `Lower` method returns a `StringMessage` as a parameter).
4. Build the `ClientMethodDescriptor`.
5. Create a `ClientServiceDescriptor` for service named `StringService`.
6. Add the method descriptor that we created in step 4.
7. We create a `Channel` to the service that is running on `localhost:1408`.
8. Finally, we create our `GrpcServiceClient` by using the above mentioned `ClientServiceDescriptor`
and `Channel`.
9. Finally, we invoke the `Lower` method (which returns a CompletableFuture).

NOTE: The `unary` method shown in the example above is just one of many helper
      methods available in the `GrpcServiceClient` class. See the full list
      link:{javadoc-base-url-api}/GrpcServiceClient.html[here].

The example above adds just one Unary method to our client service. We can add other
types of methods (like server sttreamin, client streaming etc.) as well. Also, because
we set the request and response types, the client framework will pick the correct
(protbuf) Marshaller for the `Lower` method. If we didn't set the request and rsponse
types, then Java serialization will be used as a default.

== Creating gRPC clients for non protobuf services

If your service is not using protobuf for serialization, then the Client framework allows
you to programmatically create clients to invoke methods on the service.

Lets use the HelloService
[source,java]
----
public static void main(String[] args) throws Exception {
    ClientServiceDescriptor descriptor = ClientServiceDescriptor.builder(HelloService.class)    // (1)
                                                                .unary("SayHello")              // (2)
                                                                .build();

    Channel channel = ManagedChannelBuilder.forAddress("localhost", 1408)                       // (3)
                                           .usePlaintext()
                                           .build();

    GrpcServiceClient client = GrpcServiceClient.create(channel, descriptor);                   // (4)

    CompletableFuture<String> future = client.unary("SayHello");                                // (5)
    System.out.println(future.get());                                                           // (6)

}
----


